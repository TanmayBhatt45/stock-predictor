# -*- coding: utf-8 -*-
"""App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rnS6_0UJ9zY631zz1GovYBk11BPNR7DT
"""

import os
import warnings

# Suppress TensorFlow warnings and logs
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
warnings.filterwarnings('ignore')

import tensorflow as tf
import numpy as np
import pandas as pd
import yfinance as yf
from flask import Flask, request, jsonify
from flask_cors import CORS
from tensorflow.keras.models import load_model
from sklearn.preprocessing import MinMaxScaler

# Explicitly configure TensorFlow to use CPU
tf.config.set_visible_devices([], 'GPU')

# Suppress TensorFlow logging
tf.get_logger().setLevel('ERROR')

# ✅ Load trained model
model = load_model("best_bayes_optimized_model.keras")

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

@app.route("/", methods=["GET"])
def home():
    return jsonify({"message": "Stock Predictor API is running! Use the /predict endpoint."})

@app.route("/predict", methods=["POST"])
def predict():
    try:
        data = request.get_json()
        ticker = data.get("ticker", "").strip().upper()
        days_to_predict = int(data.get("days", 1))

        if not ticker:
            return jsonify({"error": "Missing 'ticker' parameter"}), 400
        if days_to_predict <= 0:
            return jsonify({"error": "Days must be greater than 0"}), 400

        # ✅ Fetch historical stock data
        df = yf.download(ticker, period="5y")
        df = df[['Close']]

        # ✅ Normalize data using MinMaxScaler
        scaler = MinMaxScaler(feature_range=(0, 1))
        df_scaled = scaler.fit_transform(df)

        # ✅ Prepare last 60 days as input sequence
        sequence_length = 60
        last_sequence = df_scaled[-sequence_length:].reshape(1, sequence_length, 1)

        # ✅ Predict future prices
        predicted_prices = []
        current_input = last_sequence.copy()

        for _ in range(days_to_predict):
            next_pred = model.predict(current_input, verbose=0)
            predicted_prices.append(next_pred[0][0])
            current_input = np.append(current_input[:, 1:, :], [[[next_pred[0][0]]]], axis=1)

        # ✅ Convert predictions back to actual stock prices
        predicted_prices = scaler.inverse_transform(np.array(predicted_prices).reshape(-1, 1))

        # ✅ Generate future trading dates
        future_dates = pd.bdate_range(start=pd.Timestamp.today(), periods=days_to_predict)

        # ✅ Return predictions as JSON
        predictions = [{"date": str(date.date()), "predicted_price": float(price)}
                       for date, price in zip(future_dates, predicted_prices.flatten())]

        return jsonify({"ticker": ticker, "predictions": predictions})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ✅ Proper port binding for Render
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 10000))  # Render assigns PORT dynamically
    app.run(host="0.0.0.0", port=port)